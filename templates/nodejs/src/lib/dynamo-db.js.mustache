{{#projectStyle.db.isDynamoDB}}
/**
 * DynamoDB Helper
 */

const AWS = require('aws-sdk')
const config = require('config')
const merge = require('merge-deep')

AWS.config.setPromisesDependency(require('bluebird'))

// init dynamo database endpoint
if (config.DYNAMODB.AWS_DYNAMODB_ENDPOINT) {
  AWS.config.update({
    region: config.DYNAMODB.AWS_REGION,
    endpoint: config.DYNAMODB.AWS_DYNAMODB_ENDPOINT
  })
} else {
  AWS.config.update({
    region: config.DYNAMODB.AWS_REGION
  })
}

/**
 * DynamoDB client item operator.
 */
class DynamoItem {
  /**
   * Init dynamo item.
   * @param {Object} param - the init params
   */
  constructor (param) {
    this.param = param || {}
  }

  /**
   * Set dynamo db table name.
   * @param {String} tableName - the table name
   * @returns {DynamoItem} a copy of a DynamoItem that combines the TableName property
   */
  table (tableName) {
    return new DynamoItem(merge(this.param, { TableName: tableName }))
  }

  /**
   * Set dynamo db table index name.
   * @param {String} indexName - the index name
   * @returns {DynamoItem} a copy of a DynamoItem that combines IndexName property
   */
  index (indexName) {
    return new DynamoItem(merge(this.param, { IndexName: indexName }))
  }

  /**
   * Add 'and' conjunction for filter expression.
   * @returns {DynamoItem} a copy of a DynamoItem that combines 'AND' in filter expression
   */
  and () {
    const orginFilter = this.param.FilterExpression
    if (!orginFilter) return new DynamoItem(this.param)
    let opt = {
      FilterExpression: orginFilter + ' AND '
    }
    return new DynamoItem(merge(this.param, opt))
  }

  /**
   * Add 'or' conjunction for filter expression.
   * @returns {DynamoItem} a copy of a DynamoItem that combines 'OR' in filter expression
   */
  or () {
    const orginFilter = this.param.FilterExpression
    if (!orginFilter) return new DynamoItem(this.param)
    let opt = {
      FilterExpression: orginFilter + ' OR '
    }
    return new DynamoItem(merge(this.param, opt))
  }

  /**
   * Add 'equal' condition for filter expression.
   * @param {String} fieldName - the field to use
   * @param {*} valueObj - the value to use
   * @returns {DynamoItem} a copy of a DynamoItem that combines the field equal filter
   */
  equalFind (fieldName, valueObj) {
    let filter = this.appendFilter(`#${fieldName} = :${fieldName}Value`)
    let opt = this.getFilterOpt(filter, fieldName, valueObj)
    return new DynamoItem(merge(this.param, opt))
  }

  /**
   * Append filter expression.
   * @param {String} filter - the filter expression to append
   * @returns {String} content of the filter condition
   */
  appendFilter (filter) {
    if (this.param.FilterExpression) {
      return this.param.FilterExpression + ' ' + filter
    }
    return filter
  }

  /**
   * Gets the filter expression that has the specified field and value.
   * @param {String} filter - the filter expression to set
   * @param {String} fieldName - the field name used in the filter
   * @param {*} valueObj - the field value used in the filter
   * @returns {Object} filter object with property name and value
   */
  getFilterOpt (filter, fieldName, valueObj) {
    let opt = {
      FilterExpression: filter,
      ExpressionAttributeNames: {},
      ExpressionAttributeValues: {}
    }

    opt.ExpressionAttributeNames[`#${fieldName}`] = fieldName
    opt.ExpressionAttributeValues[`:${fieldName}Value`] = valueObj
    return opt
  }

  /**
   * Append fields that need to be returned.
   * @param {Array} fields - a collection of field name
   * @returns {DynamoItem} a copy of a DynamoItem attach the fields that need to be projected
   */
  projectionAppend (fields) {
    let proj = this.param.ProjectionExpression || ''
    if (proj.length > 0) proj = proj + ','
    proj = proj + fields.join(',')

    return new DynamoItem(merge(this.param, {
      ProjectionExpression: proj
    }))
  }

  /**
   * Returns all fields.
   * @returns {DynamoItem} a copy of a DynamoItem that removed projection constraints
   */
  projectionAll () {
    let op = merge({}, this.param)
    delete op.ProjectionExpression
    return new DynamoItem(op)
  }

  /**
   * Set the fields you want to return
   * @param {Array} fields - the fields that need to be returned.
   * @returns {DynamoItem} a copy of a DynamoItem that set the projection constraint.
   */
  projectionSet (fields) {
    let opt = { ExpressionAttributeNames: {} }
    const filedNames = fields.map(field => {
      opt.ExpressionAttributeNames[`#${field}`] = field
      return `#${field}`
    })

    return new DynamoItem(merge(this.param, opt, { ProjectionExpression: filedNames.join(',') }))
  }

  /**
   * Append dynamo operation items.
   * @param {Object} itemObj - the item to append
   * @returns {DynamoItem} a copy of a DynamoItem that combined the itemObj
   */
  item (itemObj) {
    return new DynamoItem(merge(this.param, {
      Item: itemObj
    }))
  }

  /**
   * Set key information for dynamo item.
   * @param {Object} keyObj - the key obj
   * @returns {DynamoItem} a copy of a DynamoItem that combines the Key property
   */
  key (keyObj) {
    const params = merge({}, this.param)
    delete params.Key
    return new DynamoItem(merge(params, {
      Key: keyObj
    }))
  }

  /**
   * Set record search start key for dynamo item.
   * @param {Object} key - the search start position
   * @returns {DynamoItem} a copy of a DynamoItem that set ExclusiveStartKey value
   */
  startKey (key) {
    const params = merge({}, this.param)
    delete params.ExclusiveStartKey
    return new DynamoItem(merge(params, {
      ExclusiveStartKey: key
    }))
  }

  /**
   * Check if there are filtering conditions.
   * @returns {Boolean} check result
   */
  hasFilter () {
    return !!this.param.FilterExpression
  }

  /**
   * Return dynamo client option info.
   * @returns {Object} the param in DynamoItem
   */
  option () {
    return merge({}, this.param)
  }
}

module.exports.DynamoItem = DynamoItem

module.exports.DynamoDb = new AWS.DynamoDB.DocumentClient()

{{/projectStyle.db.isDynamoDB}}
{{^projectStyle.db.isDynamoDB}}
// TODO: Remove this file
{{/projectStyle.db.isDynamoDB}}
