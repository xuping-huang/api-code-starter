const AWS = require('aws-sdk')
const merge = require('merge-deep')
const config = require('../config/config')
const { hashCode } = require('./common')

AWS.config.setPromisesDependency(require('bluebird'))

// init dynamo database endpoint
if (config.db.endpoint) {
  AWS.config.update({
    region: config.db.region,
    endpoint: config.db.endpoint
  })
} else {
  AWS.config.update({
    region: config.db.region
  })
}

/**
 * DynamoDB client item operator
 */
class DynamoItem {
  /**
   * Init dynamo item
   * @param {object} param - the init params
   */
  constructor (param) {
    this.param = param || {}
  }

  /**
   * Set dynamo db table name
   * @param {string} tableName - the table name
   */
  table (tableName) {
    return new DynamoItem(merge(this.param, { TableName: tableName }))
  }


  /**
   * Set dynamo db table index name
   * @param {string} indexName - the index name
   */
  index (indexName) {
    return new DynamoItem(merge(this.param, { IndexName: indexName }))
  }

  /**
   * Set count only condition with the specified field
   * @param {string} fieldName - the field name
   */
  countOnly (fieldName) {
    return new DynamoItem(merge(this.param, {
      FilterExpression: `#name = :a and #name = :b`,
      ProjectionExpression: '#name',
      ExpressionAttributeNames: {
        '#name': fieldName
      },
      ExpressionAttributeValues: {
        ':a': 'a',
        ':b': 'b'
      }
    }))
  }

  /**
   * Add and conj for filter expression
   * /
  and () {
    const orginFilter = this.param.FilterExpression
    if (!orginFilter) return new DynamoItem(this.param)
    let opt = {
      FilterExpression: orginFilter + ' AND '
    }
    return new DynamoItem(merge(this.param, opt))
  }

  /**
   * Add or conj for filter expression
   * /
  or () {
    const orginFilter = this.param.FilterExpression
    if (!orginFilter) return new DynamoItem(this.param)
    let opt = {
      FilterExpression: orginFilter + ' OR '
    }
    return new DynamoItem(merge(this.param, opt))
  }

  /**
   * Add contains condition for filter expression
   * @param {string} fieldName - the field to use
   * @param {*} valueObj - the value to use
   */
  contains (fieldName, valueObj) {
    let filter = this.getFilter(`contains(#${fieldName}, :${fieldName}Value)`)
    let opt = this.getFilterOpt(filter, fieldName, valueObj)
    return new DynamoItem(merge(this.param, opt))
  }

  /**
   * Add equal condition for filter expression
   * @param {string} fieldName - the field to use
   * @param {*} valueObj - the value to use
   */
  equalFind (fieldName, valueObj) {
    let filter = this.getFilter(`#${fieldName} = :${fieldName}Value`)
    let opt = this.getFilterOpt(filter, fieldName, valueObj)
    return new DynamoItem(merge(this.param, opt))
  }
  /**
   * Add between condition for filter expression
   * @param {string} fieldName - the field to use
   * @param {*} valueObj - the value to use
   */
  between (fieldName, startValue, endValue) {
    let filter = this.getFilter(`#${fieldName} between :${fieldName}StartValue and :${fieldName}EndValue`)
    let opt = {
      FilterExpression: filter,
      ExpressionAttributeNames: {},
      ExpressionAttributeValues: {}
    }

    opt.ExpressionAttributeNames[`#${fieldName}`] = fieldName
    opt.ExpressionAttributeValues[`:${fieldName}StartValue`] = startValue
    opt.ExpressionAttributeValues[`:${fieldName}EndValue`] = endValue
    return new DynamoItem(merge(this.param, opt))
  }
  /**
   * Add greater equal condition for filter expression
   * @param {string} fieldName - the field to use
   * @param {*} valueObj - the value to use
   */
  greaterEqual (fieldName, valueObj) {
    let filter = this.getFilter(`#${fieldName} >= :${fieldName}Value`)
    let opt = this.getFilterOpt(filter, fieldName, valueObj)
    return new DynamoItem(merge(this.param, opt))
  }
  /**
   * Add less equal condition for filter expression
   * @param {string} fieldName - the field to use
   * @param {*} valueObj - the value to use
   */
  lessEqual (fieldName, valueObj) {
    let filter = this.getFilter(`#${fieldName} <= :${fieldName}Value`)
    let opt = this.getFilterOpt(filter, fieldName, valueObj)
    return new DynamoItem(merge(this.param, opt))
  }
  /**
   * Append filter expression
   * @param {string} filter - the filter expression to append
   */
  getFilter (filter) {
    if (this.param.FilterExpression) {
      return this.param.FilterExpression + ' ' + filter
    }
    return filter
  }
  /**
   * Get filter expression with specify field and value
   * @param {string} filter - the filter expression to set
   * @param {string} fieldName - the field name used in filter
   * @param {*} valueObj - the value used in filter
   */
  getFilterOpt (filter, fieldName, valueObj) {
    let opt = {
      FilterExpression: filter,
      ExpressionAttributeNames: {},
      ExpressionAttributeValues: {}
    }

    opt.ExpressionAttributeNames[`#${fieldName}`] = fieldName
    opt.ExpressionAttributeValues[`:${fieldName}Value`] = valueObj
    return opt
  }

  /**
   * Append fields need to be returned
   * @param {array} fields - the field name list
   */
  projectionAppend (fields) {
    let proj = this.param.ProjectionExpression || ''
    if (proj.length > 0) proj = proj + ','
    proj = proj + fields.join(',')

    return new DynamoItem(merge(this.param, {
      ProjectionExpression: proj
    }))
  }

  /**
   * Return all fields
   */
  projectionAll () {
    let op = merge({}, this.param)
    delete op.ProjectionExpression
    return new DynamoItem(op)
  }

  /**
   * Append dynamo operate item
   * @param {object} itemObj - the item to be appended
   */
  item (itemObj) {
    return new DynamoItem(merge(this.param, {
      Item: itemObj
    }))
  }
  /**
   * Set key info for dynamo client item
   * @param {object} keyObj - the key obj
   */
  key (keyObj) {
    return new DynamoItem(merge(this.param, {
      Key: keyObj
    }))
  }
  /**
   * Set return records limit
   * @param {integer} max - the max number of return records
   */
  limit (max) {
    return new DynamoItem(merge(this.param, {
      Limit: max
    }))
  }
  /**
   * Set record search start key
   * @param {object} key - the search start position after the obj
   */
  startKey (key) {
    return new DynamoItem(merge(this.param, {
      ExclusiveStartKey: key
    }))
  }
  /**
   * Append update option for Transcation
   * @param {object} option - the option to update
   */
  transcationUpdate (option) {
    if (!this.param.TransactItems) {
      return new DynamoItem(merge(this.param, {
        TransactItems: [
          { Update: option }
        ]
      }))
    } else {
      let newParam = merge({}, this.param)
      newParam.TransactItems.push({ Update: option })
      return new DynamoItem(newParam)
    }
  }
  /**
   * Whether there are filtering conditions
   */
  hasFilter () {
    return !!this.param.FilterExpression
  }

  /**
   * Clean Limit info in dynamo client option
   */
  cleanLimit () {
    let data = merge({}, this.param)
    delete data.Limit
    delete data.ExclusiveStartKey
    return new DynamoItem(data)
  }

  /**
   * Return dynamo client option info
   */
  option () {
    return merge({}, this.param)
  }
}

exports.DynamoItem = DynamoItem

exports.DynamoDb = new AWS.DynamoDB.DocumentClient()
