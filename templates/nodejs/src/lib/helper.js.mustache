/**
 * This file defines helper methods
 */

const _ = require('lodash')
const Joi = require('joi')
{{#dependencies.other.pagination}}
const querystring = require('querystring')
const pagination = require('pagination')
{{/dependencies.other.pagination}}
const error = require('./app-error')
const { Role } = require('../constants')
{{#projectStyle.db.isSqlite}}
const Model = require('../model/index')
{{/projectStyle.db.isSqlite}}

/**
 * Wrap all functions of object to express middleware
 * @param {Object|Function|Array} obj the object to be wrapped
 * @returns {Object|Array} the wrapped object
 */
const wrapMiddleware = (obj) => {
  if (_.isArray(obj)) {
    return obj.map(wrapMiddleware)
  }
  if (_.isFunction(obj)) {
    if (obj.constructor.name === 'AsyncFunction') {
      return function (req, res, next) {
        obj(req, res, next).catch(next)
      }
    }
    return obj
  }
  _.each(obj, (value, key) => {
    obj[key] = wrapMiddleware(value)
  })
  return obj
}
module.exports.wrapMiddleware = wrapMiddleware

/**
 * Check if exists.
 * @param {Array} source the array in which to search for the term
 * @param {Array | String} term the term to search
 * @returns {Boolean} the check result
 */
module.exports.checkIfExists = (source, term) => {
  let terms

  if (!_.isArray(source)) {
    throw new Error('Source argument should be an array')
  }

  source = source.map(s => s.toLowerCase())

  if (_.isString(term)) {
    terms = term.toLowerCase().split(' ')
  } else if (_.isArray(term)) {
    terms = term.map(t => t.toLowerCase())
  } else {
    throw new Error('Term argument should be either a string or an array')
  }

  const intersection = source.filter(v => terms.includes(v))
  if (intersection && intersection.length > 0) {
    return true
  }

  return false
}

/**
 * Check if the user has admin role
 * @param {Object} authUser the user
 * @returns {Boolean} check result
 */
module.exports.hasAdminRole = (authUser) => {
  for (let i = 0; i < authUser.roles.length; i++) {
    if (authUser.roles[i].toLowerCase() === Role.Admin.toLowerCase()) {
      return true
    }
  }
  return false
}

/**
 * Determines whether the text form of two parameters is equal when the case and the first and last spaces are ignored.
 * @param {String} valueA the first value
 * @param {String} valueB the second value
 * @return {Boolean} Comparison result of whether two parameters are equal
 */
module.exports.equalIgnoreCase = (valueA, valueB) => {
  if (!valueA || !valueB) return false
  return String(valueA).trim().toLowerCase() === String(valueB).trim().toLowerCase()
}
{{#dependencies.other.pagination}}

/**
 * Get link for a given page.
 * @param {Object} req the HTTP request
 * @param {Number} page the page number
 * @returns {String} link for the page
 */
module.exports.getPageLink = (req, page) => {
  const q = _.assignIn({}, req.query, { page })
  return `${req.protocol}://${req.get('Host')}${req.baseUrl}${req.path}?${querystring.stringify(q)}`
}

/**
 * Set HTTP response headers from result.
 * @param {Object} req the HTTP request
 * @param {Object} res the HTTP response
 * @param {Object} result the operation result
 */
module.exports.setResHeaders = (req, res, result) => {
  const totalPages = Math.ceil(result.total / result.perPage)
  if (result.page < totalPages) {
    res.set('X-Next-Page', result.page + 1)
  }
  res.set('X-Page', result.page)
  res.set('X-Per-Page', result.perPage)
  res.set('X-Total', result.total)
  res.set('X-Total-Pages', totalPages)
  // set Link header
  if (totalPages > 0) {
    let link = `<${getPageLink(req, 1)}>; rel="first", <${getPageLink(req, totalPages)}>; rel="last"`
    if (result.page > 1) {
      link += `, <${getPageLink(req, result.page - 1)}>; rel="prev"`
    }
    if (result.page < totalPages) {
      link += `, <${getPageLink(req, result.page + 1)}>; rel="next"`
    }
    res.set('Link', link)
  }
}

/**
 * Format page link with the params
 * @param {Object} req - the request object
 * @param {Integer} page - the page number
 * @param {String} lastEvaluatedKey - returned LastEvaluatedKey in search
 * @return {String} formatted page link
 */
const formatPageLink = (req, page, lastEvaluatedKey) => {
  let url = `${req.protocol}://${req.hostname}${req.originalUrl}`
  url = url.replace(/([^\w])page=\d+/gi, `$1page=${page}`)
  if (url.match(/([^\w])lastEvaluatedKey=[^&]*/gi)) {
    url = url.replace(/([^\w])lastEvaluatedKey=[^&]*/gi, '')
  }
  if (lastEvaluatedKey) {
    if (url.match(/\?/gi)) {
      url = url + `&lastEvaluatedKey=${JSON.stringify(lastEvaluatedKey)}`
    } else {
      url = url + `lastEvaluatedKey=${JSON.stringify(lastEvaluatedKey)}`
    }
  }
  return url
}

/**
 * Return Link info in pagination headers
 * @param {Object} req - the request object
 * @param {String} lastEvaluatedKey - returnned LastEvaluatedKey in search
 * @param {Integer} current - current page number
 * @param {Integer} pageCount - total page number
 * @return {String} formatted link info
 */
const formatLink = (req, lastEvaluatedKey, current, pageCount) => {
  let link = ''
  if (current === 1) {
    // first page
    if (current === pageCount) {
      // only one page
      link = ''
    } else {
      if (pageCount === 2) {
        link = `<${formatPageLink(req, current + 1, lastEvaluatedKey)}>; rel="next"`
      } else {
        link = `<${formatPageLink(req, current + 1, lastEvaluatedKey)}>; rel="next", <${formatPageLink(req, pageCount)}>; rel="last"`
      }
    }
  } else {
    if (current === pageCount) {
      // last page
      link = `<${formatPageLink(req, 1)}>; rel="first", <${formatPageLink(req, current - 1)}>; rel="prev"`
    } else {
      // mid page
      link = `<${formatPageLink(req, 1)}>; rel="first", <${formatPageLink(req, current - 1)}>; rel="prev", <${formatPageLink(req, current + 1, lastEvaluatedKey)}>; rel="next", <${formatPageLink(req, pageCount)}>; rel="last"`
    }
  }

  return link
}

/**
 * Format page info for pagination headers
 * @param {Object} req - the request object
 * @param {Object} data - the data object to handle
 * @return {Object} formatted page object
 */
module.exports.formatPagingData = (req, data) => {
  let page = data.Page
  if ((page - 1) * data.PerPage >= data.Total) {
    page = 1
  }
  const paginator = new pagination.SearchPaginator({
    prelink: '/',
    current: page,
    rowsPerPage: data.PerPage,
    totalResult: data.Total
  })

  const pageData = paginator.getPaginationData()

  return {
    Items: data.Items,
    Headers: {
      'X-Next-Page': pageData.next,
      'X-Page': pageData.current,
      'X-Per-Page': data.PerPage,
      'X-Prev-Page': pageData.previous,
      'X-Total': pageData.totalResult,
      'X-Total-Pages': pageData.pageCount,
      'Link': formatLink(req, data.LastEvaluatedKey, pageData.current, pageData.pageCount)
    }
  }
}
{{/dependencies.other.pagination}}

/**
 * Verify IP address validity
 * @param {String} ipAddress IP address
 * @return {Boolean} IP Address Validation Result
 */
module.exports.validIpAddress = (ipAddress) => {
  const schema = Joi.object({
    ipAddress: Joi.string().ip({ version: ['ipv4', 'ipv6'] }).required()
  })
  const { error } = Joi.validate({ ipAddress }, schema)
  if (error) {
    return false
  }
  return true
}

/**
 * Verify the validity of type of install
 * @param {String} typeOfEnum a enum type
 * @return {Boolean} Type validation result
 */
module.exports.validEnumType = (typeOfEnum) => {
  const schema = Joi.object({
    typeOfEnum: Joi.string().trim().lowercase().valid(['manual', 'packaged']).required()
  })
  const { error } = Joi.validate({ typeOfEnum }, schema)
  if (error) {
    return false
  }
  return true
}

/**
 * Verify the validity of email address
 * @param {String} emailAddress email address
 * @return {Boolean} Email address validation result
 */
module.exports.validEmail = (emailAddress) => {
  const schema = Joi.object({
    emailAddress: Joi.string().trim().email().required()
  })
  const { error } = Joi.validate({ emailAddress }, schema)
  if (error) {
    return false
  }
  return true
}
{{#projectStyle.db.isSqlite}}

/**
 * Check to see if the user ID exists in the table.
 * @param {Uuid} userId the user id
 * @return {Object} When the user ID exists, it returns the user data for it, otherwise null is returned.
 */
module.exports.checkUserExist = async (userId) => {
  const user = await Model.UserModel.findByPk(userId, { raw: true })
  if (!user) {
    return Promise.reject(new error.NotFoundError(`User id '${userId}' not found.`))
  }
  return Promise.resolve(user)
}
{{/projectStyle.db.isSqlite}}
